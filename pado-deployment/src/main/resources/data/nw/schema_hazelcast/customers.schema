## ============================================================
## Generated: 2016-05-05 14:28:29
## Data File: customers.csv
## This file was generated by "import_csv -schema" as follows:
##    IsKeyAutoGen=true
##    Delimiter=,
##    IsTemporal=false
##    TemporalType=eternal
##    StartRow=9
##    <Field names extracted from the data file on line 8>
## ============================================================

GridPath=nw/customers

# If IsKeyColumns is true then the CSV file contains key columns in addition
# to value columns. If false, then the CSV file contains only the value columns.
# Default: false
IsKeyColumns=false

# Generate keys automatically. Typically, unique keys are extracted
# from the data objects by specifying "Primary" but at times
# the data objects may not be enough to create primary keys.
# By setting IsKeyAutoGen to true, the CSV file loader can 
# automatically generate UUID keys.
IsKeyAutoGen=false

# CompositeKeyDelimiter is a separator for a String composite key
# constructed with multiple primary fields defined. Default: . (period)
CompositeKeyDelimiter=.

# RoutingKeyIndexes is a comma-separated list of routing key indexes
# of the String compoisite key. For example, if a composite key is
# "newco.it.ct" and the routing indexes are "2,1" then the routing key
# extracted is "ct.it". 2 is for "ct", 1 is for "it".
# RoutingKeyIndexes always overrides PrimaryRouting defined in the field
# list.
#RoutingKeyIndexes=

# KeyClass defines the class of the key objects that are inserted
# in the underlying data grid path. If temporal, then this class
# is wrapped in ITemporalKey as the identity key. If KeyClass is String
# or undefined and IsKeyAutoGen is false then String keys are created.
# If KeyClass is a composite class then the property name must exactly
# match the field names defined in this file. For example, for the
# field name, "CoMpany", the composite class must define the method
# name set/getCoMpany(). Note that all composite key classes other
# than the String type must implement com.netcrest.pado.IRouterKey.
KeyClass=String

# ValueClass defines the class of the value objects that are inserted
# in the underlying data grid path. If temporal, then this class is
# wrapped in ITemporalData.
ValueClass=org.hazelcast.demo.nw.data.Customer

# KeyTypeClass defines the schema class for JsonLite. 
KeyTypeClass=org.hazelcast.demo.nw.data.Customer

# EntryFilterClass filters each key/value pair created by
# the file importer.
#EntryFilterClass=

# Delimiter is ,
Delimiter=,
FileLoaderClass=com.netcrest.pado.tools.hazelcast.file.HazelcastCsvFileLoader
BatchSize=5000
DateFormat=yyyyMMdd

# If IsSplit is true then the data file is split into multiple smaller files
# and assigned to threads to load them in parallel. The number of threads
# is set in etc/client/csv.properties or etc/client/scheduler.properties.
# IMPORTANT: IsSplit=true is currently supported for only 8-bit charsets
#            and tested for US-ASCII. IsSplit must be set to false for all
#            unsupported charsets.
IsSplit=false

# Default Charset is US-ASCII. On Unix, use the "file" command to 
# determine the charset of data files. Some supported charsets are
#   US-ASCII   Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set
#   ISO-8859-1 ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1
#   UTF-8      Eight-bit UCS Transformation Format
#   UTF-16BE   Sixteen-bit UCS Transformation Format, big-endian byte order
#   UTF-16LE   Sixteen-bit UCS Transformation Format, little-endian byte order
#   UTF-16     Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark
Charset=UTF-8

# LineSeparator is the new-line character(s). For example, \r\n for CR-LF.
# Default: \n
#LineSeparator=

# QuoteEscape is the escape character for quote as a field value.
# Default: ".
#QuoteEscape=

# --- Temporal spec ---
# If IsTemporal is false then all other temporal properties except
# IdentityKey are ignored and non-temporal objects are created. 
IsTemporal=false

# TemporalType must be one of eternal, forever, mortal
# If eternal, then temporal times are not required.
# If times are defined then TemporalType is ignored.
# In Pado, the beginning of time is 1970-01-01T00:00:00.000Z
# and the end of time is 2099-12-31'T'23:59:59.999Z. These
# times are used to represent eternal and forever temporal objects.
TemporalType=eternal
TemporalStartTime=19700101
TemporalEndTime=20991231
TemporalWrittenTime=19700101

# Username is optional. If specified then it overrides the Pado login user name.
#Username=

# List comma-separted column names to exclude from the data object.
SkipColumns=

IsCaseSensitive=false
# Row number begins from 1. Set StartRow to skip the header rows.
# Default: 1
StartRow=2

# ------------------------------------------------------------------------------
# Field:
#    Define the field types. The fields must be in the same order as the columns
#    in the CSV data file. List field names of the value class. If JsonLite, 
#    then list the KeyType names.  Note that if the value type is KeyType or
#    POJO, then the field types defined here are ignored and the fields defined
#    by KeyType or POJO are used instead.
# Primary:
#    If a field is part of the primary key then define it with the cagegory id,
#    Primary. The field order of the composite primary key can be defined by
#    specifying the primary indexes beginning from 0. If primary indexes are not
#    specified then the field list order determines the construction of the 
#    composite key. If a composite key class is defined by setting KeyClass then
#    the field names listed here must match the composite key class properties
#    (getters and setters). Note that primary indexes do not applied to the
#    composite key class and they are ignored.
# PrimaryRouting:
#    By default, the key is the routing key. If a part of the key is to be
#    used to construct the routing key then define such fields with the
#    category id, PrimaryRouting.
# Temporal: 
#    The temporal attributes are predetermined and therefore must strictly
#    define in the following field order:
#    - Identity key fields must be defined first at the beginning of the field
#      list.
#    - Define the resto temporal fields in the order of 
#      StartValidTime, EndValidTime, WrittenTime, Username. 
#    - Define other fields from the value class.
# Temporal Example:
#    Key, java.lang.String, Primary
#    StartValidTime, Date, Temporal
#    EndValidTime, Date, Temporal
#    WrittenTime, Date, Temporal
#    Username, String, Temporal
#    Field1, String
#    Field2, int
#    ...
# Path Coloation Example:
#    By specifying PrimaryRouting, grid paths can be co-located without introducing
#    custom IRoutingKey classes. In the example below, the region path colocated
#    with the company path with the Country field as the rounting key. All of
#    "us" entries for both company and region are stored in the same server.
#
#    Path    Colocated With Composite Key Fields RoutingKey Example
#    ------- -------------  -------------------- ---------- -------
#    company                ComanyName.Country   Country    "newco.us"
#    region  company        State.Country        Country    "ct.us"
#    
#
# Format: <field-name>, [<field-type>], [Primary|PrimaryRouting|Temporal|Value], [<primary index>]
#    <field-name>   Name of the field
#    [<field-type>] Field data type, primitives, primitive wrappers, String, Date, BigDecimal
#                   Default: String
#    [Primary|PrimaryRouting|Temporal|Value] 
#                   Primary - a primary field
#                   PrimaryRouting - a primary field that is part of the routing key.
#                                    If none of the fields are PrimaryRouting then the key
#                                    is used as the routing key.
#                   Temporal - a temporal value
#                   Value - a value
#                   Default: Value
#   [<primary index>]  Primary field index. Composite key is constructed in the
#                      order of primary field indexes. It must begin from 0.
#                      If undefined, then the order in which Primary field names
#                      are defined is assumed.
#   [RoutingKey] If specified, then the primary key is used as part of the
#                routing key for targetting the server to store the key.
#                RoutingKey m
#
# Special Fields:
#    Special fields are prefixed with ‘+’, i.e., +Special. These fields are not
#    part of the data source but are included in the data object with the
#    specified values. 
#
#    <field-type>/<value> pair: If <field-type>, then <value> is converted to the specified
#       field type. 
#    <macro-name>/<comma separated field names> pair: If <macro-name> is specified, 
#       then <comma separated field names> passed into the specified macro. The macro
#       result is assigned to the field.
#
# Special Field Examples:
#    +Source, String, Mars
#    +Type, int, 100
# ------------------------------------------------------------------------------
CustomerId, String, Primary
CompanyName
ContactName
ContactTitle
Address
City
Region
PostalCode
Country
Phone
Fax
